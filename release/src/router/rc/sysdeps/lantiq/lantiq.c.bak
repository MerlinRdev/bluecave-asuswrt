/*
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
 * MA 02111-1307 USA
 */
/* rewrite by paldier */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <bcmnvram.h>
#include <shutils.h>
#include <rc.h>
#include <shared.h>
#include <fapi_wlan_private.h>
#include <fapi_wlan.h>
#include <help_objlist.h>
#include <wlan_config_api.h>

int wav_ep_up(int unit)
{
	return fapi_wlan_up(get_staifname(unit), 0, 1);
}

void wlconf_pre()
{
	generate_wl_para(0, -1);
	generate_wl_para(1, -1);
}

int get_wlan_service_status(int bssidx, int vifidx)
{
	wl_wave_unit();
	return wave_is_radio_on(bssidx, vifidx);
}

void set_wlan_service_status(int bssidx, int vifidx, int enabled)
{
	int time = 3;
	int action = 0;
	while(!nvram_get_int("wave_ready"))
	{
		_dprintf("[%s][%d] wave_ready==0, wait... [%d][%d][%d]\n", __func__, __LINE__, bssidx, vifidx, enabled);
		--time;
		sleep(10);
		if(time == 0)
		{
			_dprintf("[%s][%d] wait wave_ready=1 over 20 seconds, please check wave_monitor status, skip [%d][%d][%d]\n", __func__, __LINE__, bssidx, vifidx, enabled);
			return;
		}
	}
	while(nvram_get_int("wave_action"))
	{
		_dprintf("wave_action != IDLE, wait... [%s]\n", __func__);
		sleep(1);
	}
#if 0
	if(bssidx || ((bssidx|enabled) = enabled, enabled != 1))
	{
		if((bssidx|enabled) != 0)
		{
			if(bssidx != 1)
				return 1;
			if(enabled == 1)
				return trigger_wave_monitor(__func__, __LINE__, WAVE_ACTION_RE_AP5G_ON);
			else if(enabled)
				return 1;
			return trigger_wave_monitor(__func__, __LINE__, WAVE_ACTION_RE_AP5G_OFF);
		} else
			return trigger_wave_monitor(__func__, __LINE__, WAVE_ACTION_RE_AP2G_OFF);
	} else
		return trigger_wave_monitor(__func__, __LINE__, WAVE_ACTION_RE_AP2G_ON);
#endif
	if(bssidx == 0 && enabled == 1)
		trigger_wave_monitor(__func__, __LINE__, WAVE_ACTION_RE_AP2G_ON);
	else if((bssidx == 0 && enabled == 0)
		trigger_wave_monitor(__func__, __LINE__, WAVE_ACTION_RE_AP2G_OFF);
	else if(bssidx == 1 && enabled == 1)
		trigger_wave_monitor(__func__, __LINE__, WAVE_ACTION_RE_AP5G_ON);
	else if(bssidx == 1 && enabled == 0)
		trigger_wave_monitor(__func__, __LINE__, WAVE_ACTION_RE_AP5G_OFF);
}
#if 0
int get_wlan_service_status(int bssidx, int vifidx)
{
#if 0
	FILE *fp = NULL;
	char maxassoc_file[128]={0};
	char buf[64]={0};
	char maxassoc[64]={0};
	char tmp[128] = {0}, prefix[] = "wlXXXXXXXXXX_";
	char *ifname = NULL;

	if(vifidx > 0)
		snprintf(prefix, sizeof(prefix), "wl%d.%d_", bssidx, vifidx);
	else
		snprintf(prefix, sizeof(prefix), "wl%d", bssidx);

	ifname = nvram_safe_get(strcat_r(prefix, "ifname", tmp));


	snprintf(maxassoc_file, sizeof(maxassoc_file), "/tmp/maxassoc.%s", ifname);

	doSystem("wl -i %s maxassoc > %s", ifname, maxassoc_file);

	if ((fp = fopen(maxassoc_file, "r")) != NULL) {
		fscanf(fp, "%s", buf);
		fclose(fp);
	}
	sscanf(buf, "%s", maxassoc);

	return atoi(maxassoc);
#endif
	return 0;
}

int set_wlan_service_status(int bssidx, int vifidx, int enabled)
{

#if 0
	char tmp[128]={0}, prefix[] = "wlXXXXXXXXXX_", wlprefix[] = "wlXXXXXXXXXX_";
	char *ifname = NULL;

	if(vifidx > 0)
		snprintf(prefix, sizeof(prefix), "wl%d.%d_", bssidx, vifidx);
	else
		snprintf(prefix, sizeof(prefix), "wl%d", bssidx);

	memset(wlprefix, 0x00, sizeof(wlprefix));
	snprintf(wlprefix, sizeof(wlprefix), "wl%d_", bssidx);

	ifname = nvram_safe_get(strcat_r(prefix, "ifname", tmp));

	if (enabled == 0) {
		doSystem("wl -i %s maxassoc 0", ifname);
	}
	else {
#ifdef HND_ROUTER
		doSystem("wl -i %s maxassoc %d", ifname, nvram_get_int(strcat_r(wlprefix, "cfg_maxassoc", tmp)));
#else
		doSystem("wl -i %s maxassoc %d", ifname, nvram_get_int(strcat_r(wlprefix, "maxassoc", tmp)));
#endif
	}
#endif
	return 0;
}
#endif

void set_pre_sysdep_config(int iftype)
{
}

void set_post_sysdep_config(int iftype)
{
	char word[256], *next = NULL, cmd[64], ifnames[128];
	int result, i;
	memset(cmd, 0, sizeof(cmd));
	if(iftype == 0x01){
		strcpy(cmd, "ppacmd addlan -i eth1");
		doSystem(cmd);
	} else {
		result = 0x07;	
		if(iftype){
			result = (iftype & 0x02) != 0;
			if((iftype & 0x04) != 0)
				result |= 0x02;
		}
		if((iftype & 0x08) != 0)
			result |= 0x04;
		strcpy(ifnames, nvram_safe_get("sta_ifnames"));
		i = 0;
		foreach(word, ifnames, next) {
			if(((result >> i) & 1) != 0){
				snprintf(cmd, sizeof(cmd), "echo \"add %s\" > /proc/l2nat/dev", word);
				doSystem(cmd);
				snprintf(cmd, sizeof(cmd), "ppacmd addlan -i %s", word);
				doSystem(cmd);
			}
			++i;
		}
	}
}

int get_radar_status(int bssidx)
{
	if(bssidx)
		return nvram_get_int("radar_status");
	else
		return 0;
}

#ifdef LANTIQ_BSD
void bandstr_sync_wl_settings(void)
{
	char tmp[100], tmp2[100], prefix[16] = "wlXXXXXXXXXX_", wlprefix[16] = "wlXXXXXXXXXX_";
	int i, n;
	memset(tmp, 0, sizeof(tmp));
	memset(tmp2, 0, sizeof(tmp2));
	n = num_of_wl_if();
	snprintf(prefix, sizeof(prefix), "wl%d_", 0);
	for(i = 1; i < n; i++){
		snprintf(wlprefix, sizeof(wlprefix), "wl%d_", i);
		nvram_set(strcat_r(wlprefix, "ssid", tmp), nvram_safe_get(strcat_r(prefix, "ssid", tmp2)));
		nvram_set(strcat_r(wlprefix, "auth_mode_x", tmp), nvram_safe_get(strcat_r(prefix, "auth_mode_x", tmp2)));
		nvram_set(strcat_r(wlprefix, "wep_x", tmp), nvram_safe_get(strcat_r(prefix, "wep_x", tmp2)));
		nvram_set(strcat_r(wlprefix, "key", tmp), nvram_safe_get(strcat_r(prefix, "key", tmp2)));
		nvram_set(strcat_r(wlprefix, "key1", tmp), nvram_safe_get(strcat_r(prefix, "key1", tmp2)));
		nvram_set(strcat_r(wlprefix, "key2", tmp), nvram_safe_get(strcat_r(prefix, "key2", tmp2)));
		nvram_set(strcat_r(wlprefix, "key3", tmp), nvram_safe_get(strcat_r(prefix, "key3", tmp2)));
		nvram_set(strcat_r(wlprefix, "key4", tmp), nvram_safe_get(strcat_r(prefix, "key4", tmp2)));
		nvram_set(strcat_r(wlprefix, "phrase_x", tmp), nvram_safe_get(strcat_r(prefix, "phrase_x", tmp2)));
		nvram_set(strcat_r(wlprefix, "crypto", tmp), nvram_safe_get(strcat_r(prefix, "crypto", tmp2)));
		nvram_set(strcat_r(wlprefix, "wpa_psk", tmp), nvram_safe_get(strcat_r(prefix, "wpa_psk", tmp2)));
		nvram_set(strcat_r(wlprefix, "radius_ipaddr", tmp), nvram_safe_get(strcat_r(prefix, "radius_ipaddr", tmp2)));
		nvram_set(strcat_r(wlprefix, "radius_key", tmp), nvram_safe_get(strcat_r(prefix, "radius_key", tmp2)));
		nvram_set(strcat_r(wlprefix, "radius_port", tmp), nvram_safe_get(strcat_r(prefix, "radius_port", tmp2)));
		nvram_set(strcat_r(wlprefix, "closed", tmp), nvram_safe_get(strcat_r(prefix, "closed", tmp2)));
	}
}
#endif

#ifdef RTCONFIG_WPS_ENROLLEE
void start_wsc_enrollee(void)
{
	nvram_set("wps_enrollee", "1");
	doSystem("wpa_cli -i %s wps_pbc", get_staifname(0));//only 2.4G?
}

void stop_wsc_enrollee(void)
{
	int i;
	char word[256], *next, ifnames[128];
	char fpath[64], sta[64];

	i = 0;
	strcpy(ifnames, nvram_safe_get("wl_ifnames"));
	foreach(word, ifnames, next) {
		if (i >= MAX_NR_WL_IF)
			break;
		SKIP_ABSENT_BAND_AND_INC_UNIT(i);
		strcpy(sta, get_staifname(i));
		doSystem("wpa_cli -i %s wps_cancel", sta);
		i++;
	}
}

char *getWscStatus_enrollee(int unit)
{
	char buf[512];
	FILE *fp;
	int len;
	char *pt1, *pt2;

	snprintf(buf, sizeof(buf), "wpa_cli -i %s status", get_staifname(unit));
	fp = popen(buf, "r");
	if (fp) {
		memset(buf, 0, sizeof(buf));
		len = fread(buf, 1, sizeof(buf), fp);
		pclose(fp);
		if (len > 1) {
			buf[len-1] = '\0';
			pt1 = strstr(buf, "wpa_state=");
			if (pt1) {
				pt2 = pt1 + strlen("wpa_state=");
				pt1 = strstr(pt2, "address=");
				if (pt1) {
					*pt1 = '\0';
					chomp(pt2);
				}
				return pt2;
			}
		}
	}

	return "";
}
#endif

int Pty_procedure_check(int unit, int wlif_count)
{
	return 0;
}

int is_default()
{
	if(g_reboot || g_upgrade || IS_ATE_FACTORY_MODE() || nvram_get_int("obd_Setting") == 1 || nvram_get_int("x_Setting") == 1 )
		return 0;
	else
		return nvram_get_int("obdeth_Setting");
}

int no_need_obd(void)
{
	if(g_reboot || g_upgrade || IS_ATE_FACTORY_MODE() || (nvram_get("sw_mode") || nvram_get_int("sw_mode") != 1) || 
    nvram_get_int("obd_Setting") == 1 || nvram_get_int("x_Setting") == 1 && nvram_get_int("obdeth_Setting") == 1 ) ||
	!nvram_get_int("wave_ready"))
		return -1;
	else
		return pids("obd");
}

int no_need_obdeth(void)
{
	if(g_reboot || g_upgrade || IS_ATE_FACTORY_MODE() || (nvram_get("sw_mode") || nvram_get_int("sw_mode") != 1) || 
    nvram_get_int("obd_Setting") == 1 || nvram_get_int("x_Setting") == 1 || nvram_get_int("obdeth_Setting") == 1 ) ||
	!nvram_get_int("wave_ready"))
		return -1;
	else
		return pids("obd_eth");
}

int amas_wait_wifi_ready(void)
{
	int result = 0;

	while(1)
	{
		result = nvram_get_int("wave_ready");
		if (result)
			break;
		sleep(5);
	}
	return result;
}
